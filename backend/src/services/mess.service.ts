import mongoose from 'mongoose';
import jwt from 'jsonwebtoken';
import Mess, { IMess } from '../models/Mess';
import InviteLink from '../models/InviteLink';
import User from '../models/User';
import { env } from '../config/env';
import authorizationService from './authorization.service';

/**
 * DTOs for MessService
 */
export interface CreateMessDTO {
  name: string;
  memberLimit: number;
  description?: string;
}

export interface UpdateMessDTO {
  name?: string;
  memberLimit?: number;
  description?: string;
}

export interface MemberInfo {
  userId: string;
  name: string;
  email: string;
  role: 'Owner' | 'Admin' | 'Member';
  joinedAt: Date;
}

export interface MessResponse {
  id: string;
  name: string;
  memberLimit: number;
  description?: string;
  inviteCode: string;
  members: MemberInfo[];
  createdAt: Date;
  updatedAt: Date;
}

export interface InviteLinkResponse {
  inviteLink: string;
  expiresAt: Date;
}

/**
 * MessService handles mess creation, management, and member operations
 * 
 * Requirements: 2.1, 2.3, 2.4, 2.6, 3.1, 3.2, 3.3, 3.4, 3.5, 3.6
 */
class MessService {
  /**
   * Create a new mess with Owner assignment and invite code generation
   * @param ownerId - User ID of the mess creator
   * @param messData - Mess creation data
   * @returns Created mess response
   * Requirements: 2.1, 2.3
   */
  async createMess(ownerId: string, messData: CreateMessDTO): Promise<MessResponse> {
    // Validate user ID
    if (!mongoose.Types.ObjectId.isValid(ownerId)) {
      throw new Error('Invalid user ID');
    }

    // Verify user exists
    const user = await User.findById(ownerId);
    if (!user) {
      throw new Error('User not found');
    }

    // Validate member limit
    if (messData.memberLimit < 6 || messData.memberLimit > 20) {
      throw new Error('Member limit must be between 6 and 20');
    }

    // Create mess with owner as first member
    const mess = new Mess({
      name: messData.name,
      memberLimit: messData.memberLimit,
      description: messData.description,
      members: [
        {
          userId: new mongoose.Types.ObjectId(ownerId),
          role: 'Owner',
          joinedAt: new Date(),
        },
      ],
    });

    // Save mess (invite code will be generated by pre-save hook)
    await mess.save();

    return this.formatMessResponse(mess);
  }

  /**
   * Update mess details with authorization check
   * @param messId - Mess ID to update
   * @param userId - User ID performing the update
   * @param updates - Fields to update
   * @returns Updated mess response
   * Requirements: 2.4
   */
  async updateMess(
    messId: string,
    userId: string,
    updates: UpdateMessDTO
  ): Promise<MessResponse> {
    // Validate IDs
    if (!mongoose.Types.ObjectId.isValid(messId)) {
      throw new Error('Invalid mess ID');
    }
    if (!mongoose.Types.ObjectId.isValid(userId)) {
      throw new Error('Invalid user ID');
    }

    // Check authorization (Owner only)
    const canManage = await authorizationService.canManageMess(userId, messId);
    if (!canManage) {
      throw new Error('Unauthorized: Only mess owner can update mess details');
    }

    // Find mess
    const mess = await Mess.findById(messId);
    if (!mess) {
      throw new Error('Mess not found');
    }

    // Validate member limit if being updated
    if (updates.memberLimit !== undefined) {
      // Ensure new limit is not less than current member count (check this first)
      if (updates.memberLimit < mess.members.length) {
        throw new Error('Cannot set member limit below current member count');
      }
      // Then validate range
      if (updates.memberLimit < 6 || updates.memberLimit > 20) {
        throw new Error('Member limit must be between 6 and 20');
      }
    }

    // Apply updates
    if (updates.name !== undefined) mess.name = updates.name;
    if (updates.memberLimit !== undefined) mess.memberLimit = updates.memberLimit;
    if (updates.description !== undefined) mess.description = updates.description;

    await mess.save();

    return this.formatMessResponse(mess);
  }

  /**
   * Get mess details with member verification
   * @param messId - Mess ID
   * @param userId - User ID requesting the mess
   * @returns Mess response
   * Requirements: 2.4
   */
  async getMess(messId: string, userId: string): Promise<MessResponse> {
    // Validate IDs
    if (!mongoose.Types.ObjectId.isValid(messId)) {
      throw new Error('Invalid mess ID');
    }
    if (!mongoose.Types.ObjectId.isValid(userId)) {
      throw new Error('Invalid user ID');
    }

    // Find mess
    const mess = await Mess.findById(messId);
    if (!mess) {
      throw new Error('Mess not found');
    }

    // Verify user is a member
    const userObjectId = new mongoose.Types.ObjectId(userId);
    const isMember = mess.members.some((m) => m.userId.equals(userObjectId));
    if (!isMember) {
      throw new Error('Unauthorized: User is not a member of this mess');
    }

    return this.formatMessResponse(mess);
  }

  /**
   * Get all messes for a user
   * @param userId - User ID
   * @returns Array of mess responses
   * Requirements: 2.6, 10.1
   */
  async getUserMesses(userId: string): Promise<MessResponse[]> {
    // Validate user ID
    if (!mongoose.Types.ObjectId.isValid(userId)) {
      throw new Error('Invalid user ID');
    }

    // Find all messes where user is a member
    const userObjectId = new mongoose.Types.ObjectId(userId);
    const messes = await Mess.find({
      'members.userId': userObjectId,
    });

    return Promise.all(messes.map((mess) => this.formatMessResponse(mess)));
  }

  /**
   * Generate invite link with expiration
   * @param messId - Mess ID
   * @param ownerId - Owner user ID
   * @param expiresInHours - Hours until link expires
   * @returns Invite link response
   * Requirements: 3.1
   */
  async generateInviteLink(
    messId: string,
    ownerId: string,
    expiresInHours: number = 24
  ): Promise<InviteLinkResponse> {
    // Validate IDs
    if (!mongoose.Types.ObjectId.isValid(messId)) {
      throw new Error('Invalid mess ID');
    }
    if (!mongoose.Types.ObjectId.isValid(ownerId)) {
      throw new Error('Invalid user ID');
    }

    // Check authorization (Owner only)
    const canManage = await authorizationService.canManageMess(ownerId, messId);
    if (!canManage) {
      throw new Error('Unauthorized: Only mess owner can generate invite links');
    }

    // Verify mess exists
    const mess = await Mess.findById(messId);
    if (!mess) {
      throw new Error('Mess not found');
    }

    // Calculate expiration date
    const expiresAt = new Date();
    expiresAt.setHours(expiresAt.getHours() + expiresInHours);

    // Generate JWT token for invite link
    const token = jwt.sign(
      {
        messId,
        type: 'invite',
      },
      env.jwtAccessSecret,
      {
        expiresIn: `${expiresInHours}h`,
      }
    );

    // Create invite link record
    const inviteLink = new InviteLink({
      messId: new mongoose.Types.ObjectId(messId),
      token,
      createdBy: new mongoose.Types.ObjectId(ownerId),
      expiresAt,
    });

    await inviteLink.save();

    // Construct full invite link URL (in production, this would be the frontend URL)
    const inviteLinkUrl = `${env.frontendUrl || 'http://localhost:3000'}/join/${token}`;

    return {
      inviteLink: inviteLinkUrl,
      expiresAt,
    };
  }

  /**
   * Join mess by invite code with capacity check and duplicate prevention
   * @param userId - User ID joining the mess
   * @param inviteCode - Mess invite code
   * @returns Mess response
   * Requirements: 3.2, 3.4, 3.5, 3.6
   */
  async joinMessByCode(userId: string, inviteCode: string): Promise<MessResponse> {
    // Validate user ID
    if (!mongoose.Types.ObjectId.isValid(userId)) {
      throw new Error('Invalid user ID');
    }

    // Verify user exists
    const user = await User.findById(userId);
    if (!user) {
      throw new Error('User not found');
    }

    // Find mess by invite code
    const mess = await Mess.findOne({ inviteCode: inviteCode.toUpperCase() });
    if (!mess) {
      throw new Error('Invalid invite code');
    }

    // Check if user is already a member (duplicate prevention)
    const userObjectId = new mongoose.Types.ObjectId(userId);
    const isAlreadyMember = mess.members.some((m) => m.userId.equals(userObjectId));
    if (isAlreadyMember) {
      throw new Error('User is already a member of this mess');
    }

    // Check capacity
    if (mess.members.length >= mess.memberLimit) {
      throw new Error('Mess has reached maximum capacity');
    }

    // Add user as member with default role
    mess.members.push({
      userId: userObjectId,
      role: 'Member',
      joinedAt: new Date(),
    });

    await mess.save();

    return this.formatMessResponse(mess);
  }

  /**
   * Join mess by invite link with token verification
   * @param userId - User ID joining the mess
   * @param inviteLinkToken - Invite link token
   * @returns Mess response
   * Requirements: 3.3, 3.4, 3.5, 3.6
   */
  async joinMessByLink(userId: string, inviteLinkToken: string): Promise<MessResponse> {
    // Validate user ID
    if (!mongoose.Types.ObjectId.isValid(userId)) {
      throw new Error('Invalid user ID');
    }

    // Verify user exists
    const user = await User.findById(userId);
    if (!user) {
      throw new Error('User not found');
    }

    // Verify and decode token
    let decoded: any;
    try {
      decoded = jwt.verify(inviteLinkToken, env.jwtAccessSecret);
    } catch (error) {
      throw new Error('Invalid or expired invite link');
    }

    // Verify token type
    if (decoded.type !== 'invite') {
      throw new Error('Invalid invite link token');
    }

    // Find invite link record
    const inviteLink = await InviteLink.findOne({ token: inviteLinkToken });
    if (!inviteLink) {
      throw new Error('Invite link not found or has been revoked');
    }

    // Check if link has expired
    if (inviteLink.expiresAt < new Date()) {
      throw new Error('Invite link has expired');
    }

    // Find mess
    const mess = await Mess.findById(inviteLink.messId);
    if (!mess) {
      throw new Error('Mess not found');
    }

    // Check if user is already a member (duplicate prevention)
    const userObjectId = new mongoose.Types.ObjectId(userId);
    const isAlreadyMember = mess.members.some((m) => m.userId.equals(userObjectId));
    if (isAlreadyMember) {
      throw new Error('User is already a member of this mess');
    }

    // Check capacity
    if (mess.members.length >= mess.memberLimit) {
      throw new Error('Mess has reached maximum capacity');
    }

    // Add user as member with default role
    mess.members.push({
      userId: userObjectId,
      role: 'Member',
      joinedAt: new Date(),
    });

    await mess.save();

    return this.formatMessResponse(mess);
  }

  /**
   * Remove member from mess with authorization
   * @param messId - Mess ID
   * @param ownerId - Owner user ID performing the removal
   * @param memberId - Member user ID to remove
   * Requirements: 2.5, 4.2
   */
  async removeMember(messId: string, ownerId: string, memberId: string): Promise<void> {
    // Validate IDs
    if (!mongoose.Types.ObjectId.isValid(messId)) {
      throw new Error('Invalid mess ID');
    }
    if (!mongoose.Types.ObjectId.isValid(ownerId)) {
      throw new Error('Invalid owner ID');
    }
    if (!mongoose.Types.ObjectId.isValid(memberId)) {
      throw new Error('Invalid member ID');
    }

    // Check authorization (Owner only)
    const canManage = await authorizationService.canManageMess(ownerId, messId);
    if (!canManage) {
      throw new Error('Unauthorized: Only mess owner can remove members');
    }

    // Find mess
    const mess = await Mess.findById(messId);
    if (!mess) {
      throw new Error('Mess not found');
    }

    // Cannot remove the owner
    const memberObjectId = new mongoose.Types.ObjectId(memberId);
    const memberToRemove = mess.members.find((m) => m.userId.equals(memberObjectId));
    
    if (!memberToRemove) {
      throw new Error('Member not found in this mess');
    }

    if (memberToRemove.role === 'Owner') {
      throw new Error('Cannot remove the mess owner');
    }

    // Remove member
    mess.members = mess.members.filter((m) => !m.userId.equals(memberObjectId));

    await mess.save();
  }

  /**
   * Format mess document to response DTO
   * @param mess - Mess document
   * @returns Formatted mess response
   */
  private async formatMessResponse(mess: IMess): Promise<MessResponse> {
    // Populate member information
    const memberIds = mess.members.map((m) => m.userId);
    const users = await User.find({ _id: { $in: memberIds } });

    const members: MemberInfo[] = mess.members.map((member) => {
      const user = users.find((u) => u._id.equals(member.userId));
      return {
        userId: member.userId.toString(),
        name: user?.name || 'Unknown',
        email: user?.email || 'Unknown',
        role: member.role,
        joinedAt: member.joinedAt,
      };
    });

    return {
      id: mess._id.toString(),
      name: mess.name,
      memberLimit: mess.memberLimit,
      description: mess.description,
      inviteCode: mess.inviteCode,
      members,
      createdAt: mess.createdAt,
      updatedAt: mess.updatedAt,
    };
  }
}

// Export singleton instance
export default new MessService();
